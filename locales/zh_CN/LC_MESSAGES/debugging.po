# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Taichi Developers
# This file is distributed under the same license as the taichi package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: taichi 0.6.24\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-08-02 22:06+0800\n"
"PO-Revision-Date: 2020-08-03 11:29+0800\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"X-Generator: Poedit 2.0.6\n"

#: ../../debugging.rst:2
msgid "Debugging"
msgstr "调试"

#: ../../debugging.rst:4
msgid ""
"Debugging a parallel program is not easy, so Taichi provides builtin "
"utilities that could hopefully help you debug your Taichi program."
msgstr ""
"调试并行程序并不容易，因此Taichi提供了内置的支持，希望能帮助你调试Taichi程"
"序。"

#: ../../debugging.rst:8
msgid "Run-time ``print`` in kernels"
msgstr "内核中的运行时 ``print``"

#: ../../debugging.rst:12
msgid "Debug your program with ``print()`` in Taichi-scope. For example:"
msgstr "在 Taichi 作用域内用 ``print()`` 调试程序。例如："

#: ../../debugging.rst:14
msgid ""
"@ti.kernel\n"
"def inside_taichi_scope():\n"
"    x = 233\n"
"    print('hello', x)\n"
"    #=> hello 233\n"
"\n"
"    print('hello', x * 2 + 200)\n"
"    #=> hello 666\n"
"\n"
"    print('hello', x, sep='')\n"
"    #=> hello233\n"
"\n"
"    print('hello', x, sep='', end='')\n"
"    print('world', x, sep='')\n"
"    #=> hello233world233\n"
"\n"
"    m = ti.Matrix([[2, 3, 4], [5, 6, 7]])\n"
"    print('m =', m)\n"
"    #=> m = [[2, 3, 4], [5, 6, 7]]\n"
"\n"
"    v = ti.Vector([3, 4])\n"
"    print('v =', v)\n"
"    #=> v = [3, 4]"
msgstr ""
"@ti.kernel\n"
"def inside_taichi_scope():\n"
"    x = 233\n"
"    print('hello', x)\n"
"    #=> hello 233\n"
"\n"
"    print('hello', x * 2 + 200)\n"
"    #=> hello 666\n"
"\n"
"    print('hello', x, sep='')\n"
"    #=> hello233\n"
"\n"
"    print('hello', x, sep='', end='')\n"
"    print('world', x, sep='')\n"
"    #=> hello233world233\n"
"\n"
"    m = ti.Matrix([[2, 3, 4], [5, 6, 7]])\n"
"    print('m =', m)\n"
"    #=> m = [[2, 3, 4], [5, 6, 7]]\n"
"\n"
"    v = ti.Vector([3, 4])\n"
"    print('v =', v)\n"
"    #=> v = [3, 4]"

#: ../../debugging.rst:40
msgid ""
"For now, Taichi-scope ``print`` supports string, scalar, vector, and "
"matrix expressions as arguments. ``print`` in Taichi-scope may be a "
"little different from ``print`` in Python-scope. Please see details "
"below."
msgstr ""
"目前，Taichi 作用域的 ``print`` 支持字符串、标量、矢量和矩阵表达式作为参数。"
"Taichi 作用域中的 ``print`` 可能与 Python 作用域中的 ``print`` 略有不同。请参"
"阅下面的详细信息。"

#: ../../debugging.rst:45
msgid ""
"For the **CPU and CUDA backend**, ``print`` will not work in Graphical "
"Python Shells including IDLE and Jupyter notebook. This is because these "
"backends print the outputs to the console instead of the GUI. Use the "
"**OpenGL or Metal backend** if you wish to use ``print`` in IDLE / "
"Jupyter."
msgstr ""
"对于 **CPU 和 CUDA 后端**， ``print`` 在图形 Python 层（包括 IDLE 和 "
"Jupyter notebook）中不起作用。这是因为这些后端将输出打印到控制台而不是 "
"GUI。如果你希望在 IDLE/ Jupyter 中使用 ``print`` ，请使用 **OpenGL 或"
"Metal 后端**。"

#: ../../debugging.rst:49
msgid ""
"For the **CUDA backend**, the printed result will not show up until ``ti."
"sync()`` is called:"
msgstr ""
"对于 **CUDA 后端**，打印的结果不会显示，直到 ``ti.sync()`` 被调用："

#: ../../debugging.rst:51
msgid ""
"import taichi as ti\n"
"ti.init(arch=ti.cuda)\n"
"\n"
"@ti.kernel\n"
"def kern():\n"
"    print('inside kernel')\n"
"\n"
"print('before kernel')\n"
"kern()\n"
"print('after kernel')\n"
"ti.sync()\n"
"print('after sync')"
msgstr ""
"import taichi as ti\n"
"ti.init(arch=ti.cuda)\n"
"\n"
"@ti.kernel\n"
"def kern():\n"
"    print('inside kernel')\n"
"\n"
"print('before kernel')\n"
"kern()\n"
"print('after kernel')\n"
"ti.sync()\n"
"print('after sync')"

#: ../../debugging.rst:66
msgid "obtains:"
msgstr "得到："

#: ../../debugging.rst:68
msgid ""
"before kernel\n"
"after kernel\n"
"inside kernel\n"
"after sync"
msgstr ""
"before kernel\n"
"after kernel\n"
"inside kernel\n"
"after sync"

#: ../../debugging.rst:75
msgid ""
"Note that host access or program end will also implicitly invoke ``ti."
"sync()``."
msgstr "请注意，主机访问或程序终止也将隐式触发 ``ti.sync()``.。"

#: ../../debugging.rst:79
msgid ""
"Note that ``print`` in Taichi-scope can only receive **comma-separated "
"parameter**. Neither f-string nor formatted string should be used. For "
"example:"
msgstr ""
"请注意，Taichi 作用域中的 ``print`` 只能接收 **逗号分隔参数**。不应使用 f 字"
"符串或格式化字符串。例如："

#: ../../debugging.rst:81
#, python-format
msgid ""
"import taichi as ti\n"
"ti.init(arch=ti.cpu)\n"
"a = ti.var(ti.f32, 4)\n"
"\n"
"\n"
"@ti.kernel\n"
"def foo():\n"
"    a[0] = 1.0\n"
"    print('a[0] = ', a[0]) # right\n"
"    print(f'a[0] = {a[0]}') # wrong, f-string is not supported\n"
"    print(\"a[0] = %f\" % a[0]) # wrong, formatted string is not "
"supported\n"
"\n"
"foo()"
msgstr ""
"import taichi as ti\n"
"ti.init(arch=ti.cpu)\n"
"a = ti.var(ti.f32, 4)\n"
"\n"
"\n"
"@ti.kernel\n"
"def foo():\n"
"    a[0] = 1.0\n"
"    print('a[0] = ', a[0]) # 正确\n"
"    print(f'a[0] = {a[0]}') # 错误，不支持 f-string \n"
"    print(\"a[0] = %f\" % a[0]) # 错误， 不支持格式化字符串\n"
"\n"
"foo()"

#: ../../debugging.rst:99
msgid "Compile-time ``ti.static_print``"
msgstr "编译时 ``ti.static_print``"

#: ../../debugging.rst:101
msgid ""
"Sometimes it is useful to print Python-scope objects and constants like "
"data types or SNodes in Taichi-scope. So, similar to ``ti.static`` we "
"provide ``ti.static_print`` to print compile-time constants. It is "
"similar to Python-scope ``print``."
msgstr ""
"有时，在Taichi 作用域中打印 Python 作用域的对象和常量（如数据类型或 SNodes）非"
"常有用。因此，类似于 ``ti.static`` ，我们提供 ``ti.static_print`` 来打印"
"编译时常数。它类似于 Python 作用域的 ``print`` 。"

#: ../../debugging.rst:105
msgid ""
"x = ti.var(ti.f32, (2, 3))\n"
"y = 1\n"
"\n"
"@ti.kernel\n"
"def inside_taichi_scope():\n"
"    ti.static_print(y)\n"
"    # => 1\n"
"    ti.static_print(x.shape)\n"
"    # => (2, 3)\n"
"    ti.static_print(x.dtype)\n"
"    # => DataType.float32\n"
"    for i in range(4):\n"
"            ti.static_print(i.dtype)\n"
"            # => DataType.int32\n"
"            # will only print once"
msgstr ""
"x = ti.var(ti.f32, (2, 3))\n"
"y = 1\n"
"\n"
"@ti.kernel\n"
"def inside_taichi_scope():\n"
"    ti.static_print(y)\n"
"    # => 1\n"
"    ti.static_print(x.shape)\n"
"    # => (2, 3)\n"
"    ti.static_print(x.dtype)\n"
"    # => DataType.float32\n"
"    for i in range(4):\n"
"            ti.static_print(i.dtype)\n"
"            # => DataType.int32\n"
"            # 只会打印一次"

#: ../../debugging.rst:123
msgid ""
"Unlike ``print``, ``ti.static_print`` will only print the expression "
"once at compile-time, and therefore it has no runtime cost."
msgstr ""
"与 ``print`` 不同，``ti.static_print`` 在编译时只打印一次表达式，因此没有"
"运行时成本。"

#: ../../debugging.rst:128
msgid "Runtime ``assert`` in kernel"
msgstr "内核中的运行时 ``assert``"

#: ../../debugging.rst:130
msgid ""
"Programmers may use ``assert`` statements in Taichi-scope. When the "
"assertion condition failed, a ``RuntimeError`` will be raised to "
"indicate the error."
msgstr ""
"程序员可以在 Taichi 作用域内使用 ``assert`` 语句。当断言条件失败时， "
"``RuntimeError`` 将被触发以指示错误。"

#: ../../debugging.rst:133
msgid ""
"To make ``assert`` work, first make sure you are using the **CPU "
"backend**. For performance reason, ``assert`` only works when ``debug`` "
"mode is on, For example:"
msgstr ""
"若要使 ``assert`` 正常工作，首先请确保使用 **CPU 后端** 运行程序。其次出于性能方面的考量， "
"``assert`` 仅在 ``debug`` 模式开启时有效，例如："

#: ../../debugging.rst:136
msgid ""
"ti.init(arch=ti.cpu, debug=True)\n"
"\n"
"x = ti.var(ti.f32, 128)\n"
"\n"
"@ti.kernel\n"
"def do_sqrt_all():\n"
"    for i in x:\n"
"        assert x[i] >= 0\n"
"        x[i] = ti.sqrt(x)"
msgstr ""
"ti.init(arch=ti.cpu, debug=True)\n"
"\n"
"x = ti.var(ti.f32, 128)\n"
"\n"
"@ti.kernel\n"
"def do_sqrt_all():\n"
"    for i in x:\n"
"        assert x[i] >= 0\n"
"        x[i] = ti.sqrt(x)"

#: ../../debugging.rst:149
msgid ""
"When you are done with debugging, simply set ``debug=False``. Now "
"``assert`` will be ignored and there will be no runtime overhead."
msgstr ""
"完成调试后，只需设置 ``debug=False`` 。此时， ``assert`` 将被忽略，并且不会产生"
"运行时开销。"

#: ../../debugging.rst:154
msgid "Compile-time ``ti.static_assert``"
msgstr "编译时 ``ti.static_assert``"

#: ../../debugging.rst:158
msgid ""
"Like ``ti.static_print``, we also provide a static version of "
"``assert``: ``ti.static_assert``. It can be useful to make assertions on "
"data types, dimensionality, and shapes. It works whether ``debug=True`` "
"is specified or not. When an assertion fails, it will raise an "
"``AssertionError``, just like a Python-scope ``assert``."
msgstr ""
"与 ``ti.static_print`` 一样，我们还提供了 ``assert`` 的静态版本： ``ti."
"static_assert`` 。对数据类型、维度和形状进行断言可能很有用。无论是否指定 "
"``debug=True`` ，它都有效。当断言失败时，它将引发一个 "
"``AssertionError`` ，就像 Python 作用域中的 ``assert`` 一样。"

#: ../../debugging.rst:163
msgid "For example:"
msgstr "例如："

#: ../../debugging.rst:165
msgid ""
"@ti.func\n"
"def copy(dst: ti.template(), src: ti.template()):\n"
"    ti.static_assert(dst.shape == src.shape, \"copy() needs src and dst "
"tensors to be same shape\")\n"
"    for I in ti.grouped(src):\n"
"        dst[I] = src[I]\n"
"    return x % 2 == 1"
msgstr ""
"@ti.func\n"
"def copy(dst: ti.template(), src: ti.template()):\n"
"    ti.static_assert(dst.shape == src.shape, \"copy() needs src and dst "
"tensors to be same shape\")\n"
"    for I in ti.grouped(src):\n"
"        dst[I] = src[I]\n"
"    return x % 2 == 1"

#: ../../debugging.rst:176
msgid "Pretty Taichi-scope traceback"
msgstr "优雅的 Taichi 作用域的栈回溯"

#: ../../debugging.rst:178
msgid ""
"As we all know, Python provides a useful stack traceback system, which "
"could help you locate the issue easily. But sometimes stack tracebacks "
"from **Taichi-scope** could be extremely complicated and hard to read. "
"For example:"
msgstr ""
"我们都知道，Python 提供了一个有用的堆栈回溯系统，它可以帮你轻松找到问题。"
"但有时 **Taichi 作用域** 的堆栈回溯(stack traceback)日志可能极其复杂且难以阅读。例如："

#: ../../debugging.rst:182
msgid ""
"import taichi as ti\n"
"ti.init()\n"
"\n"
"@ti.func\n"
"def func3():\n"
"    ti.static_assert(1 + 1 == 3)\n"
"\n"
"@ti.func\n"
"def func2():\n"
"    func3()\n"
"\n"
"@ti.func\n"
"def func1():\n"
"    func2()\n"
"\n"
"@ti.kernel\n"
"def func0():\n"
"    func1()\n"
"\n"
"func0()"
msgstr ""
"import taichi as ti\n"
"ti.init()\n"
"\n"
"@ti.func\n"
"def func3():\n"
"    ti.static_assert(1 + 1 == 3)\n"
"\n"
"@ti.func\n"
"def func2():\n"
"    func3()\n"
"\n"
"@ti.func\n"
"def func1():\n"
"    func2()\n"
"\n"
"@ti.kernel\n"
"def func0():\n"
"    func1()\n"
"\n"
"func0()"

#: ../../debugging.rst:205
msgid "Running this code, of course, will result in an ``AssertionError``:"
msgstr "当然，运行此代码将导致 ``AssertionError`` ："

#: ../../debugging.rst:207
msgid ""
"Traceback (most recent call last):\n"
"  File \"misc/demo_excepthook.py\", line 20, in <module>\n"
"    func0()\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 559, in "
"wrapped\n"
"    return primal(*args, **kwargs)\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 488, in "
"__call__\n"
"    self.materialize(key=key, args=args, arg_features=arg_features)\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 367, in "
"materialize\n"
"    taichi_kernel = taichi_kernel.define(taichi_ast_generator)\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 364, in "
"taichi_ast_generator\n"
"    compiled()\n"
"  File \"misc/demo_excepthook.py\", line 18, in func0\n"
"    func1()\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 39, in "
"decorated\n"
"    return fun.__call__(*args)\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 79, in "
"__call__\n"
"    ret = self.compiled(*args)\n"
"  File \"misc/demo_excepthook.py\", line 14, in func1\n"
"    func2()\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 39, in "
"decorated\n"
"    return fun.__call__(*args)\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 79, in "
"__call__\n"
"    ret = self.compiled(*args)\n"
"  File \"misc/demo_excepthook.py\", line 10, in func2\n"
"    func3()\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 39, in "
"decorated\n"
"    return fun.__call__(*args)\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 79, in "
"__call__\n"
"    ret = self.compiled(*args)\n"
"  File \"misc/demo_excepthook.py\", line 6, in func3\n"
"    ti.static_assert(1 + 1 == 3)\n"
"  File \"/root/taichi/python/taichi/lang/error.py\", line 14, in "
"wrapped\n"
"    return foo(*args, **kwargs)\n"
"  File \"/root/taichi/python/taichi/lang/impl.py\", line 252, in "
"static_assert\n"
"    assert cond\n"
"AssertionError"
msgstr ""
"Traceback (most recent call last):\n"
"  File \"misc/demo_excepthook.py\", line 20, in <module>\n"
"    func0()\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 559, in "
"wrapped\n"
"    return primal(*args, **kwargs)\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 488, in "
"__call__\n"
"    self.materialize(key=key, args=args, arg_features=arg_features)\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 367, in "
"materialize\n"
"    taichi_kernel = taichi_kernel.define(taichi_ast_generator)\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 364, in "
"taichi_ast_generator\n"
"    compiled()\n"
"  File \"misc/demo_excepthook.py\", line 18, in func0\n"
"    func1()\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 39, in "
"decorated\n"
"    return fun.__call__(*args)\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 79, in "
"__call__\n"
"    ret = self.compiled(*args)\n"
"  File \"misc/demo_excepthook.py\", line 14, in func1\n"
"    func2()\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 39, in "
"decorated\n"
"    return fun.__call__(*args)\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 79, in "
"__call__\n"
"    ret = self.compiled(*args)\n"
"  File \"misc/demo_excepthook.py\", line 10, in func2\n"
"    func3()\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 39, in "
"decorated\n"
"    return fun.__call__(*args)\n"
"  File \"/root/taichi/python/taichi/lang/kernel.py\", line 79, in "
"__call__\n"
"    ret = self.compiled(*args)\n"
"  File \"misc/demo_excepthook.py\", line 6, in func3\n"
"    ti.static_assert(1 + 1 == 3)\n"
"  File \"/root/taichi/python/taichi/lang/error.py\", line 14, in "
"wrapped\n"
"    return foo(*args, **kwargs)\n"
"  File \"/root/taichi/python/taichi/lang/impl.py\", line 252, in "
"static_assert\n"
"    assert cond\n"
"AssertionError"

#: ../../debugging.rst:246
msgid ""
"You may already feel brain fried by the annoying ``decorated``'s and "
"``__call__``'s. These are the Taichi internal stack frames. They have "
"almost no benefit for end-users but make the traceback hard to read."
msgstr ""
"分析诸如 ``decorated`` 和 ``__call__`` 之类晦涩的信息也许能让你的大脑过载着火。其实这些是"
"Taichi 内部堆栈帧。直接暴露它们对普通用户几乎没有好处，并且会使回溯日志很难阅读。"

#: ../../debugging.rst:250
msgid ""
"For this purpose, we may want to use ``ti.init(excepthook=True)``, which "
"*hooks* on the exception handler, and make the stack traceback from "
"Taichi-scope easier to read and intuitive. e.g.:"
msgstr ""
"为此，我们可能希望使用 ``ti.init(excepthook=True)`` ，这会与异常处理程序 "
"*挂钩(hook)* ，从而使 Taichi 作用域中的堆栈回溯日志更直观且易于阅读。例如："

#: ../../debugging.rst:255
msgid ""
"import taichi as ti\n"
"ti.init(excepthook=True)  # just add this option!\n"
"\n"
"..."
msgstr ""
"import taichi as ti\n"
"ti.init(excepthook=True)  # just add this option!\n"
"\n"
"..."

#: ../../debugging.rst:263
msgid "And the result will be:"
msgstr "这样结果会是："

#: ../../debugging.rst:265
msgid ""
"========== Taichi Stack Traceback ==========\n"
"In <module>() at misc/demo_excepthook.py:21:\n"
"--------------------------------------------\n"
"@ti.kernel\n"
"def func0():\n"
"    func1()\n"
"\n"
"func0()  <--\n"
"--------------------------------------------\n"
"In func0() at misc/demo_excepthook.py:19:\n"
"--------------------------------------------\n"
"    func2()\n"
"\n"
"@ti.kernel\n"
"def func0():\n"
"    func1()  <--\n"
"\n"
"func0()\n"
"--------------------------------------------\n"
"In func1() at misc/demo_excepthook.py:15:\n"
"--------------------------------------------\n"
"    func3()\n"
"\n"
"@ti.func\n"
"def func1():\n"
"    func2()  <--\n"
"\n"
"@ti.kernel\n"
"--------------------------------------------\n"
"In func2() at misc/demo_excepthook.py:11:\n"
"--------------------------------------------\n"
"    ti.static_assert(1 + 1 == 3)\n"
"\n"
"@ti.func\n"
"def func2():\n"
"    func3()  <--\n"
"\n"
"@ti.func\n"
"--------------------------------------------\n"
"In func3() at misc/demo_excepthook.py:7:\n"
"--------------------------------------------\n"
"ti.enable_excepthook()\n"
"\n"
"@ti.func\n"
"def func3():\n"
"    ti.static_assert(1 + 1 == 3)  <--\n"
"\n"
"@ti.func\n"
"--------------------------------------------\n"
"AssertionError"
msgstr ""
"========== Taichi Stack Traceback ==========\n"
"In <module>() at misc/demo_excepthook.py:21:\n"
"--------------------------------------------\n"
"@ti.kernel\n"
"def func0():\n"
"    func1()\n"
"\n"
"func0()  <--\n"
"--------------------------------------------\n"
"In func0() at misc/demo_excepthook.py:19:\n"
"--------------------------------------------\n"
"    func2()\n"
"\n"
"@ti.kernel\n"
"def func0():\n"
"    func1()  <--\n"
"\n"
"func0()\n"
"--------------------------------------------\n"
"In func1() at misc/demo_excepthook.py:15:\n"
"--------------------------------------------\n"
"    func3()\n"
"\n"
"@ti.func\n"
"def func1():\n"
"    func2()  <--\n"
"\n"
"@ti.kernel\n"
"--------------------------------------------\n"
"In func2() at misc/demo_excepthook.py:11:\n"
"--------------------------------------------\n"
"    ti.static_assert(1 + 1 == 3)\n"
"\n"
"@ti.func\n"
"def func2():\n"
"    func3()  <--\n"
"\n"
"@ti.func\n"
"--------------------------------------------\n"
"In func3() at misc/demo_excepthook.py:7:\n"
"--------------------------------------------\n"
"ti.enable_excepthook()\n"
"\n"
"@ti.func\n"
"def func3():\n"
"    ti.static_assert(1 + 1 == 3)  <--\n"
"\n"
"@ti.func\n"
"--------------------------------------------\n"
"AssertionError"

#: ../../debugging.rst:318
msgid ""
"See? Our exception hook has removed some useless Taichi internal frames "
"from traceback. What's more, although not visible in the doc, the output "
"is **colorful**!"
msgstr ""
"看到了吧？我们的异常挂钩(exception hook)已经从回溯中删除了一些无用的 Taichi 内部堆栈帧。更重要的"
"是，虽然在文档中不可见，但这些输出都是 **彩色** 的！"

#: ../../debugging.rst:325
msgid ""
"For IPython / Jupyter notebook users, the IPython stack traceback hook "
"will be overriden by the Taichi one when ``ti.enable_excepthook()``."
msgstr ""
"对于 IPython / Jupyter notebook 的用户，当 ``ti.enable_excepthook()`` 触"
"发时，IPython 原有的堆栈回溯挂钩将被 Taichi 取代。"

#: ../../debugging.rst:330
msgid "Debugging Tips"
msgstr "调试技巧"

#: ../../debugging.rst:332
msgid ""
"Debugging a Taichi program can be hard even with the builtin tools "
"above. Here we showcase some common bugs that one may encounter in a "
"Taichi program."
msgstr ""
"即使有上面的内置工具，调试 Taichi 程序也可能会很难。在这里，我们展示了一些"
" Taichi 程序中可能会遇到的常见错误。"

#: ../../debugging.rst:336
msgid "Static type system"
msgstr "静态类型系统"

#: ../../debugging.rst:338
msgid ""
"Python code in Taichi-scope is translated into a statically typed "
"language for high performance. This means code in Taichi-scope can have "
"a different behavior compared with that in Python-scope, especially when "
"it comes to types."
msgstr ""
"Taichi 作用域中的 Python 代码被翻译成静态类型语言以实现高性能。这意味着"
"Taichi 作用域中的代码与 Python 作用域中的代码可以有不同的行为，尤其是在类型方"
"面。"

#: ../../debugging.rst:340
msgid ""
"The type of a variable is simply **determined at its initialization and "
"never changes later**."
msgstr "变量的类型只 **在初始化时确定，并且之后不会做更改** 。"

#: ../../debugging.rst:342
msgid ""
"Although Taichi's static type system provides better performance, it may "
"lead to bugs if programmers carelessly used the wrong types. For example,"
msgstr ""
"虽然Taichi的静态类型系统提供更好的性能，但如果程序员不小心使用了错误的类"
"型，它可能会导致错误。例如，"

#: ../../debugging.rst:345
msgid ""
"@ti.kernel\n"
"def buggy():\n"
"    ret = 0  # 0 is an integer, so `ret` is typed as int32\n"
"    for i in range(3):\n"
"        ret += 0.1 * i  # i32 += f32, the result is still stored in "
"int32!\n"
"    print(ret)  # will show 0\n"
"\n"
"buggy()"
msgstr ""
"@ti.kernel\n"
"def buggy():\n"
"    ret = 0  # 0 是整数, 所以 `ret` 类型是 int32\n"
"    for i in range(3):\n"
"        ret += 0.1 * i  # i32 += f32，结果依旧储存在 int32!\n"
"    print(ret)  # 会显示 0\n"
"\n"
"buggy()"

#: ../../debugging.rst:356
msgid ""
"The code above shows a common bug due to Taichi's static type system. "
"The Taichi compiler should show a warning like:"
msgstr ""
"上面的代码显示了由于Taichi的静态类型系统而导致的常见错误。Taichi编译器应"
"显示以下警告："

#: ../../debugging.rst:359
msgid ""
"[W 06/27/20 21:43:51.853] [type_check.cpp:visit@66] [$19] Atomic add "
"(float32 to int32) may lose precision."
msgstr ""
"[W 06/27/20 21:43:51.853] [type_check.cpp:visit@66] [$19] Atomic add "
"(float32 to int32) may lose precision."

#: ../../debugging.rst:363
msgid ""
"This means that Taichi cannot store a ``float32`` result precisely to "
"``int32``. The solution is to initialize ``ret`` as a float-point value:"
msgstr ""
"这意味着Taichi不能将 ``float32`` 结果精确存储到 ``int32`` 。解决方案是初"
"始化 ``ret`` 作为浮点值："

#: ../../debugging.rst:366
msgid ""
"@ti.kernel\n"
"def not_buggy():\n"
"    ret = 0.0  # 0 is a floating point number, so `ret` is typed as "
"float32\n"
"    for i in range(3):\n"
"        ret += 0.1 * i  # f32 += f32. OK!\n"
"    print(ret)  # will show 0.6\n"
"\n"
"not_buggy()"
msgstr ""
"@ti.kernel\n"
"def not_buggy():\n"
"    ret = 0.0  # 0 是浮点数， 所以 `ret` 类型是 float32\n"
"    for i in range(3):\n"
"        ret += 0.1 * i  # f32 += f32. 成立！\n"
"    print(ret)  # 会显示 0.6\n"
"\n"
"not_buggy()"

#: ../../debugging.rst:380
msgid "Advanced Optimization"
msgstr "高级优化"

#: ../../debugging.rst:382
msgid ""
"Taichi has an advanced optimization engine to make your Taichi kernel to "
"be as fast as it could. But like what ``gcc -O3`` does, advanced "
"optimization may occasionally lead to bugs as it tries too hard. This "
"includes runtime errors such as:"
msgstr ""
"Taichi有一个先进的优化引擎，可以使你的Taichi内核是尽可能快。但是，就像 "
"``gcc -O3`` 一样，高级优化偶尔会导致错误，因为它过于努力了。这包括运行时"
"错误，例如："

#: ../../debugging.rst:386
msgid ""
"```RuntimeError: [verify.cpp:basic_verify@40] stmt 8 cannot have operand "
"7.```"
msgstr ""
"```RuntimeError: [verify.cpp:basic_verify@40] stmt 8 cannot have operand "
"7.```"

#: ../../debugging.rst:388
msgid ""
"You may use ``ti.init(advance_optimization=False)`` to turn off advanced "
"optimization and see if the issue still exists:"
msgstr ""
"你可以使用 ``ti.init(advanced_optimization=False)`` 关闭高级优化，并查看问"
"题是否仍然存在："

#: ../../debugging.rst:391
msgid ""
"import taichi as ti\n"
"\n"
"ti.init(advance_optimization=False)\n"
"\n"
"..."
msgstr ""
"import taichi as ti\n"
"\n"
"ti.init(advanced_optimization=False)\n"
"\n"
"..."

#: ../../debugging.rst:399
msgid ""
"Whether or not turning off optimization fixes the issue, please feel "
"free to report this bug on `GitHub <https://github.com/taichi-dev/taichi/"
"issues/new?labels=potential+bug&template=bug_report.md>`_. Thank you!"
msgstr ""
"无论是否关闭优化修复了问题，请随时在 `GitHub <https://github.com/taichi-"
"dev/taichi/issues/new?labels=potential+bug&template=bug_report.md>`_ 上报"
"告此 Bug。谢谢！"
